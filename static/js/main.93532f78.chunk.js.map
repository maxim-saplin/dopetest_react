{"version":3,"sources":["App.js","rand.js","serviceWorker.js","index.js"],"names":["funcG","rand","MBIG","MSEED","SeedArray","Array","inext","inextp","init","Seed","ii","mj","mk","subtraction","Math","abs","this","i","k","InternalSample","retVal","locINext","locINextp","next","labels","startedG","window","addEventListener","App","useState","started","setStarted","startedOnce","setStartedOnce","setMaxId","dopes","setDopes","id","hidden","onClick","width","innerWidth","height","outerHeight","prevUpdate","prevCount","accum","accumN","func","label","top","round","left","angle","color","transform","push","splice","Date","now","diff","val","toFixed","postMessage","setTimeout","startTest","map","l","key","style","position","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.93532f78.chunk.js","sourcesContent":["import React, { useState } from 'react';\nimport rand from './rand';\n\nlet labels = [];\nlet funcG;\nlet startedG = false;\n\nwindow.addEventListener(\"message\", () => {\n  funcG();\n}, true);\n\nfunction App() {\n\n  const [started, setStarted] = useState(false);\n  const [startedOnce, setStartedOnce] = useState(false);\n  const [maxId, setMaxId] = useState(-1);\n  const [dopes, setDopes] = useState(\"Warming up..\");\n\n  let startTest = () => {\n    rand.init(0);\n    //alert(rand.next());\n    setStarted(true);\n    setStartedOnce(true);\n    setDopes(\"Warming up..\");\n    startedG = true;\n\n    let width =  window.innerWidth;\n    let height = window.outerHeight;\n    let i = 0;\n    let max = 600;\n    let prevUpdate = null;\n    let prevCount = 0;\n    \n    let accum = 0;\n    let accumN = 0;\n\n    labels = [];\n\n    let func = () => {\n      let label = {};\n\n      let top = Math.round(rand.next()*height);\n      let left = Math.round(rand.next()*width);\n      let angle  = Math.round(rand.next()*width);\n      let color = \"rgb(\" + \n        Math.round(rand.next()*255) + \",\"+  \n        Math.round(rand.next()*255) + \",\" +\n        Math.round(rand.next()*255) + \")\";\n\n      label.top = top+\"px\";\n      label.left = left+\"px\";\n      label.transform = \"rotate(\"+angle+\"deg)\";\n      label.color = color;\n      label.id = i;\n\n      labels.push(label);\n\n      if (i > max){\n        labels.splice(0,1);\n\n        if (!prevUpdate) {\n           prevUpdate = Date.now();\n           prevCount = i;\n        }\n        \n        let diff = Date.now() - prevUpdate;\n        \n        if (diff >= 500) {\n           let val = ((i - prevCount) / diff * 1000);\n           accum += val;\n           accumN++;\n           setDopes(val.toFixed(2)  + \" Dopes/s\");\n           prevUpdate = Date.now();\n           prevCount = i;\n        }\n      }\n\n      if (startedG) {\n        window.postMessage(\"z\", \"*\");\n        setMaxId(i);\n      }\n      else {\n        setDopes((accum/accumN).toFixed(2)  + \" Dopes/s (AVG)\");\n      }\n\n      i++; \n    }\n   \n    funcG = func;\n    setTimeout(func, 0);\n  }\n\n  return (\n    <>\n      <span id=\"dopes\" hidden={!startedOnce} >{dopes}</span>\n      <button id=\"start\" hidden={started} onClick={() => startTest()}>@ Start</button>\n      <button id=\"stop\" hidden={!started} onClick={() => {setStarted(false); startedG = false}}>@ Break</button>\n      {labels.map(l => \n        <span key={l.id} style={{position: \"absolute\", top: l.top, left: l.left, color: l.color, transform: l.transform}}>Dope</span>\n        )}\n    </>\n  );\n}\n\nexport default App;\n","const rand = {\n  MBIG : 2000000000,\n  MSEED : 161803398,\n  SeedArray : new Array(56),\n  inext : null,\n  inextp : null,\n  init : function(Seed) {\n       let ii;\n       let mj, mk;\n\n       let subtraction = Math.abs(Seed);\n       mj = this.MSEED - subtraction;\n       this.SeedArray[55] = mj;\n       mk = 1;\n       for (let i = 1; i < 55; i++)\n       {  \n           ii = (21 * i) % 55;\n           this.SeedArray[ii] = mk;\n           mk = mj - mk;\n           if (mk < 0) mk += this.MBIG;\n           mj = this.SeedArray[ii];\n       }\n       for (let k = 1; k < 5; k++)\n       {\n           for (let i = 1; i < 56; i++)\n           {\n               this.SeedArray[i] -= this.SeedArray[1 + (i + 30) % 55];\n               if (this.SeedArray[i] < 0) this.SeedArray[i] += this.MBIG;\n           }\n       }\n       this.inext = 0;\n       this.inextp = 21;\n   },\n   InternalSample : function() {\n       let retVal;\n       let locINext = this.inext;\n       let locINextp = this.inextp;\n\n       if (++locINext >= 56) locINext = 1;\n       if (++locINextp >= 56) locINextp = 1;\n\n       retVal = this.SeedArray[locINext] - this.SeedArray[locINextp];\n\n       if (retVal === this.MBIG) retVal--;\n       if (retVal < 0) retVal += this.MBIG;\n\n       this.SeedArray[locINext] = retVal;\n\n       this.inext = locINext;\n       this.inextp = locINextp;\n\n       return retVal;\n   },\n   next : function() {\n     return (this.InternalSample() * (1.0 / this.MBIG));\n   }\n}\n\nexport default rand;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}